<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji RPG Battle</title>
    <meta name="description" content="An interactive card-based RPG battle game with emoji avatars and elemental powers.">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: manipulation;
        }
        #gameCanvas {
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #startMenu, #tutorialOverlay, #attackConfirmation, #gameOverMenu, #assignmentConfirmation, #deckOptions, #cardBrowser {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        #readyButton, #surrenderButton, #nextButton, #yesButton, #noButton, #newGameButton, #saveDeckButton, #loadDeckButton, #tutorialButton, #cardBrowserButton, #yesAssign {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
        #surrenderButton {
            background-color: #f44336;
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            padding: 10px 20px;
            font-size: 14px;
            display: none;
        }
        #tutorialButton, #cardBrowserButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            font-size: 20px;
        }
        #cardBrowserButton {
            top: 60px;
        }
        #tutorialOverlay {
            display: none;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }
        #attackConfirmation, #gameOverMenu, #assignmentConfirmation, #deckOptions {
            display: none;
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        #aStatsBox, #cardInfoBox {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 80%;
            max-height: 80%;
        }
        #aStatsBox .card-column, #cardInfoBox .card-column {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #aStatsBox .stats-column, #cardInfoBox .stats-column {
            overflow-y: auto;
        }
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .lucky-star {
            background: linear-gradient(124deg, #ff2400, #e81d1d, #e8b71d, #e3e81d, #1de840, #1ddde8, #2b1de8, #dd00f3, #dd00f3);
            background-size: 1800% 1800%;
            animation: rainbow 18s ease infinite;
        }
        .effect-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 12px;
            margin: 2px;
            cursor: pointer;
            border-radius: 3px;
        }
        @keyframes flipCard {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(180deg); }
        }
        @keyframes confetti {
            0% { transform: translate(0, 0); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)); opacity: 0; }
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            animation: confetti 2s forwards;
        }
        @keyframes shakeCard {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .elemental-weapon {
            background-color: #ffebcd;
        }
        @keyframes fireRain {
            0% { transform: translateY(-100%); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateY(100%); opacity: 0; }
        }
        @keyframes iceSweep {
            0% { transform: translateX(-100%); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%); opacity: 0; }
        }
        @keyframes lightningStrike {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }
        @keyframes earthQuake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-5deg); }
            75% { transform: translateX(5px) rotate(5deg); }
        }
        @keyframes waterSplash {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        @keyframes shakeDamage {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        @keyframes cycleHeartColors {
            0% { color: red; }
            20% { color: blue; }
            40% { color: green; }
            60% { color: orange; }
            80% { color: yellow; }
            100% { color: red; }
        }
        .damage-text {
            position: absolute;
            color: red;
            font-weight: bold;
            animation: shakeDamage 0.5s ease-in-out;
        }
        .healing-heart {
            animation: cycleHeartColors 2s infinite;
        }
        #cardBrowser {
            display: none;
            width: 80%;
            height: 80%;
            position: fixed;
            top: 10%;
            left: 10%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }
        #cardGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            overflow-y: auto;
            height: 100%;
            width: 66%;
            float: left;
        }
        #cardDetails {
            width: 33%;
            float: right;
            padding: 10px;
            box-sizing: border-box;
        }
        .card-item {
            background-color: #ffffff;
            color: #000000;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
        }
        .card-item:hover {
            transform: scale(1.05);
        }
        .avatar-rarity-indicator {
            height: 8px;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .rarity-gold {
            background-color: gold;
        }
        .rarity-green {
            background-color: green;
        }
        .rarity-grey {
            background-color: grey;
        }
        .rarity-rainbow {
            background: linear-gradient(124deg, #ff2400, #e81d1d, #e8b71d, #e3e81d, #1de840, #1ddde8, #2b1de8, #dd00f3, #dd00f3);
            background-size: 1800% 1800%;
            animation: rainbow 18s ease infinite;
        }
        .rarity-indicator {
    height: 5px;
    width: 100%;
    position: absolute;
    top: 0;
    left: 0;
}
.rarity-common { background-color: #b0b0b0; }
.rarity-uncommon { background-color: #00ff00; }
.rarity-rare { background-color: #0000ff; }
.rarity-legendary { background-color: #ffd700; }
.special-card { box-shadow: 0 0 10px gold; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="startMenu">
        <h1>Emoji RPG Battle</h1>
        <button id="readyButton">Ready</button>
    </div>
    <button id="surrenderButton">Surrender</button>
    <button id="tutorialButton">‚ùì</button>
    <button id="cardBrowserButton">üÉè</button>
    <div id="tutorialOverlay">
        <h2>Tutorial</h2>
        <div id="tutorialContent"></div>
        <button id="nextButton">Next</button>
    </div>
    <div id="attackConfirmation">
        <h2>Do you want to attack?</h2>
        <button id="yesButton">Yes</button>
        <button id="noButton">No</button>
    </div>
    <div id="assignmentConfirmation">
        <h2>Skip card assignment and attack?</h2>
        <button id="yesAssignButton">Yes</button>
        <button id="noAssignButton">No</button>
    </div>
    <div id="gameOverMenu">
        <h2 id="gameOverMessage"></h2>
        <button id="newGameButton">New Game</button>
    </div>
    <div id="aStatsBox">
        <div class="card-column"></div>
        <div class="stats-column"></div>
    </div>
    <div id="cardInfoBox">
        <div class="card-column"></div>
        <div class="stats-column"></div>
    </div>
    <div id="deckOptions">
        <h2>Deck Options</h2>
        <button id="saveDeckButton">Save Deck</button>
        <button id="loadDeckButton">Load Deck</button>
        <input type="file" id="deckFileInput" style="display: none;" accept=".deck">
    </div>
    <div id="cardBrowser">
        <div id="cardGrid"></div>
        <div id="cardDetails"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startMenu = document.getElementById('startMenu');
        const readyButton = document.getElementById('readyButton');
        const surrenderButton = document.getElementById('surrenderButton');
        const tutorialButton = document.getElementById('tutorialButton');
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialContent = document.getElementById('tutorialContent');
        const nextButton = document.getElementById('nextButton');
        const attackConfirmation = document.getElementById('attackConfirmation');
        const yesButton = document.getElementById('yesButton');
        const noButton = document.getElementById('noButton');
        const assignmentConfirmation = document.getElementById('assignmentConfirmation');
        const yesAssignButton = document.getElementById('yesAssignButton');
        const noAssignButton = document.getElementById('noAssignButton');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const newGameButton = document.getElementById('newGameButton');
        const aStatsBox = document.getElementById('aStatsBox');
        const cardInfoBox = document.getElementById('cardInfoBox');
        const deckOptions = document.getElementById('deckOptions');
        const saveDeckButton = document.getElementById('saveDeckButton');
        const loadDeckButton = document.getElementById('loadDeckButton');
        const deckFileInput = document.getElementById('deckFileInput');
        const cardBrowserButton = document.getElementById('cardBrowserButton');
        const cardBrowser = document.getElementById('cardBrowser');
        const cardGrid = document.getElementById('cardGrid');
        const cardDetails = document.getElementById('cardDetails');

        let gameStarted = false;
        let bgm;
        let tutorialStep = 0;
        let currentTurn = 'player';
        let attackingAvatar = null;
        let currentPhase = 1;
        let elementalCards, utilityCards, elementalWeapons, avatarTypes;
        let isCardBrowserDebugMode = false;
        let isCardBrowserVisible = false;
        let isViewingPlayerDeck = false;
let allTemplateCards = [];
let currentPlayerDeck = [];


// Global variables
let allCards = [];
let playerDeck = [];

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameStarted) {
                drawGame();
            }
        });

        readyButton.addEventListener('click', startGame);
        surrenderButton.addEventListener('click', surrender);
        tutorialButton.addEventListener('click', startTutorial);
        nextButton.addEventListener('click', nextTutorialStep);
        yesButton.addEventListener('click', () => confirmAttack(true));
        noButton.addEventListener('click', () => confirmAttack(false));
        yesAssignButton.addEventListener('click', () => skipAssignmentPhase(true));
        noAssignButton.addEventListener('click', () => skipAssignmentPhase(false));
        newGameButton.addEventListener('click', startNewGame);
        saveDeckButton.addEventListener('click', saveDeck);
        loadDeckButton.addEventListener('click', () => deckFileInput.click());
        deckFileInput.addEventListener('change', (e) => loadDeck(e.target.files[0]));
        cardBrowserButton.addEventListener('click', showCardBrowser);
        cardBrowserButton.addEventListener('click', function(event) {
    event.stopPropagation(); // Prevent event from bubbling up
    toggleCardBrowserDebug();
});

        function startGame() {
            gameStarted = true;
            startMenu.style.display = 'none';
            initializeGame();
            bgm = new Howl({
                src: ['https://assets.caisual.com/games/zqfqt5j5yt3lzb0v/rpg_battle_bgm.webp'],
                loop: true,
                volume: 0.5
            });
            bgm.play();
            if (!getCookie('tutorialCompleted')) {
                startTutorial();
            }
            gameLoop();
        }

        function surrender() {
            endGame("You surrendered!");
        }

        const emojis = {
    // Elemental cards
    fire: 'üî•',
    water: 'üíß',
    earth: 'üåø',
    ice: '‚ùÑÔ∏è',
    lightning: '‚ö°',
    darkness: 'üåë',
    radiant: '‚òÄÔ∏è',
    luck: 'üçÄ',
    heal: 'üíñ',
    wind: 'üå™Ô∏è',
    metal: 'üî©',
    nature: 'üçÉ',
    poison: '‚ò†Ô∏è',
    crystal: 'üíé',

    // Utility cards
    sword: 'üó°Ô∏è',
    shield: 'üõ°Ô∏è',
    bow: 'üèπ',
    wand: 'ü™Ñ',
    axe: 'ü™ì',
    hammer: 'üî®',
    dagger: 'üî™',
    staff: 'ü¶Ø',
    spear: 'ü•¢',
    mace: 'üéöÔ∏è',
    crossbow: 'üèπ',
    scythe: 'üåô',
    sling: 'üß∂',
    boomerang: 'ü™É',
    katana: 'üó°Ô∏è',
    shuriken: '‚ú¥Ô∏è',
    potion: 'üß™',
    scroll: 'üìú',
    trap: 'üï∏Ô∏è',

    // Special cards
    luckystar: 'üåü',
    thirdhand: '‚úã',
    mimic: 'üì¶',
    time_warp: '‚è≥',
    elemental_fusion: 'üåà',
    mana_burst: '‚ú®',
    shapeshifter: 'ü¶é',
    blood:'ü©∏',
    redleaf:'üçÅ',
    fall: 'üçÇ',
    blossom:'üå∏',
    sakura: 'üíÆ',
    bone:'ü¶¥',

    // Avatar types (if needed)
    elf: 'üßù',
    dwarf: 'üßî',
    wizard: 'üßô',
    fairy: 'üßö',
    vampire: 'üßõ',
    merperson: 'üßú',
    genie: 'üßû',
    zombie: 'üßü',
    superhero: 'ü¶∏',
    supervillain: 'ü¶π',

    // Fallback
    unknown: '‚ùì'
};

        class Card {
            constructor(type, emoji, effect) {
                this.type = type;
                this.emoji = emoji;
                this.effect = effect;
                this.x = 0;
                this.y = 0;
                this.width = 80;
                this.height = 120;
                this.selected = false;
                this.rotation = 0;
                this.scale = 1;
                this.targetX = 0;
                this.targetY = 0;
                this.moving = false;
                this.isLuckyStar = type === 'utility' && effect.type === 'luckyStar';
                this.isThirdHand = type === 'utility' && effect.type === 'thirdHand';
                this.isElementalWeapon = type === 'utility' && effect.isElementalWeapon;
                this.isHeal = type === 'elemental' && effect.element === 'heal';
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.scale(this.scale, this.scale);
                
                // Draw card back
                if (this.type === 'elemental') {
                    ctx.fillStyle = this.getLighterColor(this.effect.color);
                } else if (this.type === 'utility') {
                    if (this.isElementalWeapon) {
                        ctx.fillStyle = '#ffebcd'; // Light orange for elemental weapons
                    } else {
                        ctx.fillStyle = '#d3d3d3'; // Light grey for normal utility cards
                    }
                } else {
                    ctx.fillStyle = '#ffffff'; // White for avatar cards
                }
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Draw card face
                if (this.isLuckyStar || this.isThirdHand) {
                    const gradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                    gradient.addColorStop(0, 'red');
                    gradient.addColorStop(0.17, 'orange');
                    gradient.addColorStop(0.33, 'yellow');
                    gradient.addColorStop(0.5, 'green');
                    gradient.addColorStop(0.67, 'blue');
                    gradient.addColorStop(0.83, 'indigo');
                    gradient.addColorStop(1, 'violet');
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = this.selected ? '#4CAF50' : '#ffffff';
                }
                ctx.fillRect(-this.width / 2 + 5, -this.height / 2 + 5, this.width - 10, this.height - 10);
                ctx.fillStyle = '#000000';
                ctx.font = '40px Arial';
                ctx.fillText(this.emoji, -20, 15);

                // Draw elemental effect for elemental weapons
                if (this.isElementalWeapon) {
                    ctx.font = '20px Arial';
                    ctx.fillText(this.effect.elementEmoji, this.width / 2 - 25, this.height / 2 - 25);
                }

                // Draw heal animation for heal cards
                if (this.isHeal) {
                    ctx.font = '20px Arial';
                    ctx.fillStyle = this.getHealColor();
                    ctx.fillText('‚ù§Ô∏è', this.width / 2 - 25, this.height / 2 - 25);
                }

                ctx.restore();
            }

            getLighterColor(color) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                return `rgb(${Math.min(r + 50, 255)}, ${Math.min(g + 50, 255)}, ${Math.min(b + 50, 255)})`;
            }

            getHealColor() {
                const colors = ['red', 'blue', 'green', 'orange', 'yellow'];
                const index = Math.floor(Date.now() / 500) % colors.length;
                return colors[index];
            }

            isPointInside(x, y) {
                const scaledWidth = this.width * this.scale;
                const scaledHeight = this.height * this.scale;
                return x >= this.x && x <= this.x + scaledWidth && y >= this.y && y <= this.y + scaledHeight;
            }

            moveTo(targetX, targetY, callback) {
                this.targetX = targetX;
                this.targetY = targetY;
                this.moving = true;
                
                const animate = () => {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 1) {
                        this.x += dx * 0.1;
                        this.y += dy * 0.1;
                        requestAnimationFrame(animate);
                    } else {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.moving = false;
                        if (callback) callback();
                    }
                };
                
                animate();
            }
        }

        class Avatar {
            constructor(race, emoji, isPlayer) {
                this.race = race;
                this.emoji = emoji;
                this.isPlayer = isPlayer;
                this.hp = Math.floor(Math.random() * 6) + 5; // 5-10 HP
                this.maxHp = this.hp;
                this.attack = Math.floor(Math.random() * 5)// + 5; // 5-9 attack
                this.defense = Math.floor(Math.random() * 5) + 1; // 1-5 defense
                this.mana = Math.floor(Math.random() * 41)// + 10; // 10-50 mana
                this.luck = Math.floor(Math.random() * 10) + 1; // 1-10 luck
                this.x = 0;
                this.y = 0;
                this.width = 100;
                this.height = 150;
                this.attachedCards = [];
                this.rotation = 0;
                this.scale = 1;
                this.isDead = false;
                this.luckBonus = 0;
                this.luckBonusTurns = 0;
                this.maxAttachedCards = 2;
                this.hasThirdHand = false;
                this.rarityIndicator = this.getRarityIndicator();
            }

            getRarityIndicator() {
                if (this.hp >= 8 && this.attack >= 8) {
                    return 'rarity-gold';
                } else if ((this.hp >= 5 && this.hp <= 7 && this.attack >= 5 && this.attack <= 7) || 
                           (this.luck >= 5 && this.hp >= 5)) {
                    return 'rarity-green';
                } else if (this.hp <= 4 && this.attack <= 4) {
                    return 'rarity-grey';
                } else if (this.luck === 10 && this.attack === 10) {
                    return 'rarity-rainbow';
                } else {
                    return 'rarity-grey'; // Default to grey if no condition is met
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.scale(this.scale, this.scale);
                
                if (this.isDead) {
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '50px Arial';
                    ctx.fillText(emojis.tombstone, -25, 0);
                } else {
                    // Set card background color based on HP
                    if (this.hp <= 2) {
                        ctx.fillStyle = '#ff0000'; // Red
                    } else if (this.hp <= 5) {
                        ctx.fillStyle = '#ffa500'; // Orange
                    } else {
                        ctx.fillStyle = '#ffffff'; // White
                    }
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Draw AvatarRarityIndicator
                    ctx.fillStyle = this.rarityIndicator;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 8);
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = '50px Arial';
                    ctx.fillText(this.emoji, -25, -this.height / 3);
                    
                    ctx.font = '14px Arial';
                    ctx.fillText(`HP: ${this.hp}/${this.maxHp}`, -this.width / 2 + 5, 50);
                    if (this.isPlayer) {
                        ctx.fillText(`ATK: ${this.attack}`, -this.width / 2 + 5, 70);
                    }
                }

                this.attachedCards.forEach((card, index) => {
                    ctx.font = '20px Arial';
                    ctx.fillText(card.emoji, -40 + 20 * index, -this.height / 2 - 10);

                    if (card.isElementalWeapon) {
                        ctx.font = '14px Arial';
                        ctx.fillText(card.effect.elementEmoji, -40 + 20 * index, -this.height / 2 + 10);
                    }
                });

                if (this.hasThirdHand) {
                    ctx.font = '20px Arial';
                    ctx.fillText(emojis.thirdHand, this.width / 2 - 25, this.height / 2 - 25);
                }

                ctx.restore();
            }

            isPointInside(x, y) {
                const scaledWidth = this.width * this.scale;
                const scaledHeight = this.height * this.scale;
                return x >= this.x && x <= this.x + scaledWidth && y >= this.y && y <= this.y + scaledHeight;
            }

            attachCard(card) {
                if (card.isHeal) {
                    this.hp = Math.min(this.hp + 3, this.maxHp);
                    this.showHealingAnimation();
                    return true;
                }

                if (this.attachedCards.length < this.maxAttachedCards || card.isThirdHand) {
                    this.attachedCards.push(card);
                    this.applyCardEffect(card);
                    return true;
                }
                return false;
            }

            applyCardEffect(card) {
                switch (card.type) {
                    case 'elemental':
                        this.applyElementalEffect(card);
                        break;
                    case 'utility':
                        this.applyUtilityEffect(card);
                        break;
                }
            }

            applyElementalEffect(card) {
                switch (card.effect.element) {
                    case 'fire':
                        this.attack += 2;
                        break;
                    case 'water':
                        this.defense += 1;
                        break;
                    case 'earth':
                        this.hp = Math.min(this.hp + 2, this.maxHp);
                        break;
                    case 'ice':
                        this.attack += 1;
                        this.defense += 1;
                        break;
                    case 'lightning':
                        this.attack += 3;
                        break;
                    case 'darkness':
                        this.attack += 2;
                        this.defense -= 1;
                        break;
                    case 'radiant':
                        this.hp = Math.min(this.hp + 3, this.maxHp);
                        this.defense += 1;
                        break;
                    case 'luck':
                        this.luckBonus += 2;
                        this.luckBonusTurns = 2;
                        break;
                }
            }

            applyUtilityEffect(card) {
                switch (card.effect.type) {
                    case 'sword':
                        this.attack += 3;
                        break;
                    case 'shield':
                        this.defense += 2;
                        break;
                    case 'heal':
                        this.hp = Math.min(this.hp + 4, this.maxHp);
                        break;
                    case 'bow':
                        this.attack += 2;
                        break;
                    case 'wand':
                        this.mana += 20;
                        break;
                    case 'luckyStar':
                        this.attack += 5;
                        break;
                    case 'thirdHand':
                        this.maxAttachedCards += 1;
                        this.hasThirdHand = true;
                        break;
                    case 'axe':
                        this.attack += 4;
                        break;
                    case 'hammer':
                        this.attack += 3;
                        this.defense += 1;
                        break;
                    case 'dagger':
                        this.attack += 2;
                        this.luck += 1;
                        break;
                    case 'staff':
                        this.attack += 2;
                        this.mana += 10;
                        break;
                    case 'spear':
                        this.attack += 3;
                        this.defense += 1;
                        break;
                    case 'mace':
                        this.attack += 4;
                        this.defense -= 1;
                        break;
                    case 'crossbow':
                        this.attack += 3;
                        this.luck += 1;
                        break;
                    case 'scythe':
                        this.attack += 5;
                        this.defense -= 2;
                        break;
                    case 'sling':
                        this.attack += 1;
                        this.luck += 2;
                        break;
                    case 'boomerang':
                        this.attack += 2;
                        this.defense += 1;
                        this.luck += 1;
                        break;
                }

                // Apply additional effects for elemental weapons
                if (card.isElementalWeapon) {
                    switch (card.effect.element) {
                        case 'fire':
                            this.attack += 1;
                            break;
                        case 'water':this.defense += 1;
                            break;
                        case 'earth':
                            this.hp = Math.min(this.hp + 1, this.maxHp);
                            break;
                        case 'ice':
                            this.attack += 1;
                            break;
                        case 'lightning':
                            this.attack += 2;
                            break;
                        case 'darkness':
                            this.attack += 1;
                            this.luck += 1;
                            break;
                        case 'radiant':
                            this.defense += 1;
                            this.hp = Math.min(this.hp + 1, this.maxHp);
                            break;
                        case 'luck':
                            this.luck += 1;
                            break;
                    }
                }
            }

            removeEffect(effectIndex) {
                if (effectIndex >= 0 && effectIndex < this.attachedCards.length) {
                    const removedCard = this.attachedCards.splice(effectIndex, 1)[0];
                    this.revertCardEffect(removedCard);
                    return removedCard;
                }
                return null;
            }

            revertCardEffect(card) {
                switch (card.type) {
                    case 'elemental':
                        this.revertElementalEffect(card);
                        break;
                    case 'utility':
                        this.revertUtilityEffect(card);
                        break;
                }
            }

            revertElementalEffect(card) {
                switch (card.effect.element) {
                    case 'fire':
                        this.attack -= 2;
                        break;
                    case 'water':
                        this.defense -= 1;
                        break;
                    case 'earth':
                        // No reversion needed for HP boost
                        break;
                    case 'ice':
                        this.attack -= 1;
                        this.defensethis.defense -= 1;
                        break;
                    case 'lightning':
                        this.attack -= 3;
                        break;
                    case 'darkness':
                        this.attack -= 2;
                        this.defense += 1;
                        break;
                    case 'radiant':
                        this.defense -= 1;
                        break;
                    case 'luck':
                        this.luckBonus -= 2;
                        this.luckBonusTurns = 0;
                        break;
                }
            }

            revertUtilityEffect(card) {
                switch (card.effect.type) {
                    case 'sword':
                        this.attack -= 3;
                        break;
                    case 'shield':
                        this.defense -= 2;
                        break;
                    case 'heal':
                        // No reversion needed for healing
                        break;
                    case 'bow':
                        this.attack -= 2;
                        break;
                    case 'wand':
                        this.mana -= 20;
                        break;
                    case 'luckyStar':
                        this.attack -= 5;
                        break;
                    case 'thirdHand':
                        this.maxAttachedCards -= 1;
                        this.hasThirdHand = false;
                        break;
                    case 'axe':
                        this.attack -= 4;
                        break;
                    case 'hammer':
                        this.attack -= 3;
                        this.defense -= 1;
                        break;
                    case 'dagger':
                        this.attack-= 2;
                        this.luck -= 1;
                        break;
                    case 'staff':
                        this.attack -= 2;
                        this.mana -= 10;
                        break;
                    case 'spear':
                        this.attack -= 3;
                        this.defense -= 1;
                        break;
                    case 'mace':
                        this.attack -= 4;
                        this.defense += 1;
                        break;
                    case 'crossbow':
                        this.attack -= 3;
                        this.luck -= 1;
                        break;
                    case 'scythe':
                        this.attack -= 5;
                        this.defense += 2;
                        break;
                    case 'sling':
                        this.attack -= 1;
                        this.luck -= 2;
                        break;
                    case 'boomerang':
                        this.attack -= 2;
                        this.defense -= 1;
                        this.luck -= 1;
                        break;
                }

                // Revert additional effects for elemental weapons
                if (card.isElementalWeapon) {
                    switch (card.effect.element) {
                        case 'fire':
                            this.attack -= 1;
                            break;
                        case 'water':
                            this.defense -= 1;
                            break;
                        case 'earth':
                            // No reversion needed for HP boost
                            break;
                        case 'ice':
                            this.attack -= 1;
                            break;
                        case 'lightning':
                            this.attack -= 2;
                            break;
                        case 'darkness':
                            this.attack -= 1;
                            this.luck -= 1;
                            break;
                        case 'radiant':
                            this.defense -= 1;
                            break;
                        case 'luck':
                            this.luck -= 1;
                            break;
                    }
                }
            }

            updateLuckBonus() {
                if (this.luckBonusTurns > 0) {
                    this.luckBonusTurns--;
                    if (this.luckBonusTurns === 0) {
                        this.luckBonus = 0;
                    }
                }
            }

            getAttackAnimation(target) {
                const elementalCard = this.attachedCards.find(card => card.type === 'elemental');
                const utilityCard = this.attachedCards.find(card => card.type === 'utility');
                
                let animationEmoji = 'üí•';
                let soundEffect = 'attack_sound.webp';
                let animationFunction = null;
                
                if (elementalCard && utilityCard) {
                    const combo = `${elementalCard.effect.element}_${utilityCard.effect.type}`;
                    switch (combo) {
                        case 'fire_sword':
                            animationEmoji = 'üî•üó°Ô∏è';
                            soundEffect = 'fire_sword_attack.webp';
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText('üî•üó°Ô∏è', x, y);
                                y += 5;
                                return y < canvas.height;
                            };
                            break;
                        case 'ice_bow':
                            animationEmoji = '‚ùÑÔ∏èüèπ';
                            soundEffect = 'ice_bow_attack.webp';
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText('‚ùÑÔ∏èüèπ', x, y);
                                x += 10;
                                return x < canvas.width;
                            };
                            break;
                        case 'lightning_wand':
                            animationEmoji = '‚ö°ü™Ñ';
                            soundEffect = 'lightning_wand_attack.webp';
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillStyle = Math.random() > 0.5 ? 'yellow' : 'white';
                                ctx.fillText('‚ö°ü™Ñ', x, y);
                                return true;
                            };
                            break;
                        case 'water_shield':
                            animationEmoji = 'üíßüõ°Ô∏è';
                            soundEffect = 'water_shield_attack.webp';
                            animationFunction = (x, y, scale = 1) => {
                                ctx.font = `${40 * scale}px Arial`;
                                ctx.fillText('üíßüõ°Ô∏è', x, y);
                                scale += 0.1;
                                return scale < 2;
                            };
                            break;
                        case 'earth_sword':
                            animationEmoji = 'üåøüó°Ô∏è';
                            soundEffect = 'earth_sword_attack.webp';
                            animationFunction = (x, y, rotation = 0) => {
                                ctx.save();
                                ctx.translate(x, y);
                                ctx.rotate(rotation);
                                ctx.font = '40px Arial';
                                ctx.fillText('üåøüó°Ô∏è', 0, 0);
                                ctx.restore();
                                rotation += 0.1;
                                return rotation < Math.PI * 2;
                            };
                            break;
                        default:
                            animationEmoji = 'üí•';
                            soundEffect = 'default_attack.webp';
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText('üí•', x, y);
                                return false;
                            };
                    }
                } else if (elementalCard) {
                    animationEmoji = elementalCard.emoji;
                    soundEffect = `${elementalCard.effect.element}_attack.webp`;
                    switch (elementalCard.effect.element) {
                        case 'fire':
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText('üî•', x + Math.random() * 20 - 10, y);
                                y += 5;
                                return y < canvas.height;
                            };
                            break;
                        case 'water':
                            animationFunction = (x, y, scale = 1) => {
                                ctx.font = `${40 * scale}px Arial`;
                                ctx.fillText('üíß', x, y);
                                scale += 0.1;
                                return scale < 2;
                            };
                            break;
                        case 'earth':
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText('üåø', x, y);
                                x += Math.random() * 10 - 5;
                                y += Math.random() * 10 - 5;
                                return true;
                            };
                            break;
                        case 'ice':
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText('‚ùÑÔ∏è', x, y);
                                x += 10;
                                return x < canvas.width;
                            };
                            break;
                        case 'lightning':
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillStyle = Math.random() > 0.5 ? 'yellow' : 'white';
                                ctx.fillText('‚ö°', x, y);
                                return true;
                            };
                            break;
                        default:
                            animationFunction = (x, y) => {
                                ctx.font = '40px Arial';
                                ctx.fillText(animationEmoji, x, y);
                                return false;
                            };
                    }
                } else if (utilityCard) {
                    animationEmoji = utilityCard.emoji;
                    soundEffect = `${utilityCard.effect.type}_attack.webp`;
                    animationFunction = (x, y, rotation = 0) => {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(rotation);
                        ctx.font = '40px Arial';
                        ctx.fillText(animationEmoji, 0, 0);
                        ctx.restore();
                        rotation += 0.1;
                        return rotation < Math.PI * 2;
                    };
                }
                
                return {
                    emoji: animationEmoji,
                    sound: soundEffect,
                    animate: (callback) => {
                        const startX = this.x + this.width / 2;
                        const startY = this.y + this.height / 2;
                        const endX = target.x + target.width / 2;
                        const endY = target.y + target.height / 2;
                        
                        let progress = 0;
                        let additionalParam = 0;
                        const animate = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            drawGame();
                            
                            const x = startX + (endX - startX) * progress;
                            const y = startY + (endY - startY) * progress;
                            
                            if (animationFunction(x, y, additionalParam)) {
                                progress += 0.05;
                                additionalParam += 0.1;
                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                } else {
                                    callback();
                                }
                            } else {
                                callback();
                            }
                        };
                        animate();
                    }
                };
            }

            shake() {
                const originalX = this.x;
                let shakeCount = 0;
                const shakeAnimation = () => {
                    if (shakeCount < 10) {
                        this.x = originalX + (shakeCount % 2 === 0 ? 5 : -5);
                        shakeCount++;
                        requestAnimationFrame(shakeAnimation);
                    } else {
                        this.x = originalX;
                    }
                };
                shakeAnimation();
            }

            showHealingAnimation() {
                const healingHeart = document.createElement('div');
                healingHeart.textContent = '‚ù§Ô∏è';
                healingHeart.className = 'healing-heart';
                healingHeart.style.position = 'absolute';
                healingHeart.style.left = `${this.x + this.width / 2}px`;
                healingHeart.style.top = `${this.y}px`;
                healingHeart.style.fontSize = '40px';
                document.body.appendChild(healingHeart);

                setTimeout(() => {
                    healingHeart.remove();
                }, 2000);
            }

            showDamageAnimation(damage) {
                const damageText = document.createElement('div');
                damageText.textContent = `-${damage}`;
                damageText.className = 'damage-text';
                damageText.style.left = `${this.x + this.width / 2}px`;
                damageText.style.top = this.isPlayer ? `${this.y}px` : `${this.y + this.height}px`;
                document.body.appendChild(damageText);

                setTimeout(() => {
                    damageText.remove();
                }, 1000);
            }
        }

        // let playerDeck = [];
        let playerHand = [];
        let opponentHand = [];
        let playerAvatars = [];
        let opponentAvatars = [];
        let selectedCard = null;

        function initializeGame() {
    initializeGameVariables(); // Call this first to set up global variables
    initializeCards();
    applyRarityToCards();
    createPlayerDeck();
    createAvatars();
    positionElements();
    dealInitialHands();
    currentPhase = 1;
    currentTurn = 'player';
    updateSurrenderButtonVisibility();
}

        // Initialize global variables
        function initializeGameVariables() {
    elementalCards = [
        { element: 'fire', color: '#FF4500' },
        { element: 'water', color: '#1E90FF' },
        { element: 'earth', color: '#8B4513' },
        { element: 'ice', color: '#E0FFFF' },
        { element: 'lightning', color: '#FFD700' },
        { element: 'darkness', color: '#4B0082' },
        { element: 'radiant', color: '#FFFF00' },
        { element: 'luck', color: '#32CD32' },
        { element: 'heal', color: '#FF69B4' },
        // New elemental cards
        { element: 'wind', color: '#C0C0C0' },
        { element: 'metal', color: '#B87333' },
        { element: 'nature', color: '#228B22' },
        { element: 'poison', color: '#800080' },
        { element: 'crystal', color: '#B9F2FF' },
        { element: 'fall', color: '#ff8000' },
    ];

    utilityCards = [
        { type: 'sword' },
        { type: 'shield' },
        { type: 'heal' },
        { type: 'bow' },
        { type: 'wand' },
        { type: 'axe' },
        { type: 'hammer' },
        { type: 'dagger' },
        { type: 'staff' },
        { type: 'spear' },
        { type: 'mace' },
        { type: 'crossbow' },
        { type: 'scythe' },
        { type: 'sling' },
        { type: 'boomerang' },
        // New utility cards
        { type: 'katana' },
        { type: 'shuriken' },
        { type: 'potion' },
        { type: 'scroll' },
        { type: 'trap' }
    ];

    elementalWeapons = [
        { type: 'fire_sword', element: 'fire', weaponType: 'sword', elementEmoji: emojis.fire },
        { type: 'ice_bow', element: 'ice', weaponType: 'bow', elementEmoji: emojis.ice },
        { type: 'lightning_wand', element: 'lightning', weaponType: 'wand', elementEmoji: emojis.lightning },
        { type: 'water_shield', element: 'water', weaponType: 'shield', elementEmoji: emojis.water },
        { type: 'earth_axe', element: 'earth', weaponType: 'axe', elementEmoji: emojis.earth },
        { type: 'darkness_dagger', element: 'darkness', weaponType: 'dagger', elementEmoji: emojis.darkness },
        { type: 'radiant_staff', element: 'radiant', weaponType: 'staff', elementEmoji: emojis.radiant },
        { type: 'luck_boomerang', element: 'luck', weaponType: 'boomerang', elementEmoji: emojis.luck },
        { type: 'fire_mace', element: 'fire', weaponType: 'mace', elementEmoji: emojis.fire },
        { type: 'ice_spear', element: 'ice', weaponType: 'spear', elementEmoji: emojis.ice },
        // New elemental weapons
        { type: 'wind_fan', element: 'wind', weaponType: 'fan', elementEmoji: emojis.wind },
        { type: 'metal_gauntlet', element: 'metal', weaponType: 'gauntlet', elementEmoji: emojis.metal },
        { type: 'nature_staff', element: 'nature', weaponType: 'staff', elementEmoji: emojis.nature },
        { type: 'poison_dagger', element: 'poison', weaponType: 'dagger', elementEmoji: emojis.poison },
        { type: 'crystal_scepter', element: 'crystal', weaponType: 'scepter', elementEmoji: emojis.crystal }
    ];

    // New special cards
    specialCards = [
        { type: 'luckyStar', emoji: emojis.luckyStar },
        { type: 'thirdHand', emoji: emojis.thirdHand },
        { type: 'mimic', emoji: 'üì¶' },
        { type: 'time_warp', emoji: '‚è≥' },
        { type: 'elemental_fusion', emoji: 'üåà' },
        { type: 'mana_burst', emoji: '‚ú®' },
        { type: 'shapeshifter', emoji: 'ü¶é' }
    ];

    avatarTypes = [
        { race: 'elf', emoji: emojis.elf },
        { race: 'dwarf', emoji: emojis.dwarf },
        { race: 'wizard', emoji: emojis.wizard },
        { race: 'fairy', emoji: emojis.fairy },
        { race: 'vampire', emoji: emojis.vampire },
        { race: 'merperson', emoji: emojis.merperson },
        { race: 'genie', emoji: emojis.genie },
        { race: 'zombie', emoji: emojis.zombie },
        { race: 'superhero', emoji: emojis.superhero },
        { race: 'supervillain', emoji: emojis.supervillain }
    ];

}function assignRarity(card) {
    const rarityRoll = Math.random();
    if (rarityRoll < 0.6) {
        card.rarity = 'common';
    } else if (rarityRoll < 0.85) {
        card.rarity = 'uncommon';
    } else if (rarityRoll < 0.95) {
        card.rarity = 'rare';
    } else {
        card.rarity = 'legendary';
    }
    return card;
}

function applyRarityToCards() {
    elementalCards = elementalCards.map(assignRarity);
    utilityCards = utilityCards.map(assignRarity);
    elementalWeapons = elementalWeapons.map(assignRarity);
    specialCards = specialCards.map(card => ({ ...assignRarity(card), isSpecial: true }));
}



        // function createPlayerDeck() {
        //     const elementalCards = [
        //         { element: 'fire', color: '#FF4500' },
        //         { element: 'water', color: '#1E90FF' },
        //         { element: 'earth', color: '#8B4513' },
        //         { element: 'ice', color: '#E0FFFF' },
        //         { element: 'lightning', color: '#FFD700' },
        //         { element: 'darkness', color: '#4B0082' },
        //         { element: 'radiant', color: '#FFFF00' },
        //         { element: 'luck', color: '#32CD32' },
        //         { element: 'heal', color: '#FF69B4' }
        //     ];
        //     const utilityCards = [
        //         { type: 'sword' },
        //         { type: 'shield' },
        //         { type: 'heal' },
        //         { type: 'bow' },
        //         { type: 'wand' },
        //         { type: 'axe' },
        //         { type: 'hammer' },
        //         { type: 'dagger' },
        //         { type: 'staff' },
        //         { type: 'spear' },
        //         { type: 'mace' },
        //         { type: 'crossbow' },
        //         { type: 'scythe' },
        //         { type: 'sling' },
        //         { type: 'boomerang' }
        //     ];
        //     const elementalWeapons = [
        //         { type: 'fire_sword', element: 'fire', weaponType: 'sword', elementEmoji: emojis.fire },
        //         { type: 'ice_bow', element: 'ice', weaponType: 'bow', elementEmoji: emojis.ice },
        //         { type: 'lightning_wand', element: 'lightning', weaponType: 'wand', elementEmoji: emojis.lightning },
        //         { type: 'water_shield', element: 'water', weaponType: 'shield', elementEmoji: emojis.water },
        //         { type: 'earth_axe', element: 'earth', weaponType: 'axe', elementEmoji: emojis.earth },
        //         { type: 'darkness_dagger', element: 'darkness', weaponType: 'dagger', elementEmoji: emojis.darkness },
        //         { type: 'radiant_staff', element: 'radiant', weaponType: 'staff', elementEmoji: emojis.radiant },
        //         { type: 'luck_boomerang', element: 'luck', weaponType: 'boomerang', elementEmoji: emojis.luck },
        //         { type: 'fire_mace', element: 'fire', weaponType: 'mace', elementEmoji: emojis.fire },
        //         { type: 'ice_spear', element: 'ice', weaponType: 'spear', elementEmoji: emojis.ice }
        //     ];

        //     for (let i = 0; i < 40; i++) {
        //         if (Math.random() < 0.025) { // 1 in 40 chance for Lucky Star
        //             playerDeck.push(new Card('utility', emojis.luckyStar, { type: 'luckyStar' }));
        //         } else if (Math.random() < 0.025) { // 1 in 40 chance for Third Hand
        //             playerDeck.push(new Card('utility', emojis.thirdHand, { type: 'thirdHand' }));
        //         } else if (Math.random() < 0.15) { // 15% chance for elemental weapon
        //             const elementalWeapon = elementalWeapons[Math.floor(Math.random() * elementalWeapons.length)];
        //             playerDeck.push(new Card('utility', emojis[elementalWeapon.weaponType], {
        //                 type: elementalWeapon.weaponType,
        //                 element: elementalWeapon.element,
        //                 elementEmoji: elementalWeapon.elementEmoji,
        //                 isElementalWeapon: true
        //             }));
        //         } else if (Math.random() < 0.7) {
        //             const elementalEffect = elementalCards[Math.floor(Math.random() * elementalCards.length)];
        //             playerDeck.push(new Card('elemental', emojis[elementalEffect.element], elementalEffect));
        //         } else {
        //             const utilityEffect = utilityCards[Math.floor(Math.random() * utilityCards.length)];
        //             playerDeck.push(new Card('utility', emojis[utilityEffect.type], utilityEffect));
        //         }
        //     }
        //     console.log(elementalCards)
        // }
        // Define these variables in the global scope

        function createPlayerDeck() {
    playerDeck = []; // Reset the player deck

    for (let i = 0; i < 40; i++) {
        if (Math.random() < 0.025) { // 1 in 40 chance for Lucky Star
            playerDeck.push(new Card('utility', emojis.luckyStar, { type: 'luckyStar' }));
        } else if (Math.random() < 0.025) { // 1 in 40 chance for Third Hand
            playerDeck.push(new Card('utility', emojis.thirdHand, { type: 'thirdHand' }));
        } else if (Math.random() < 0.15) { // 15% chance for elemental weapon
            const elementalWeapon = elementalWeapons[Math.floor(Math.random() * elementalWeapons.length)];
            playerDeck.push(new Card('utility', emojis[elementalWeapon.weaponType], {
                type: elementalWeapon.weaponType,
                element: elementalWeapon.element,
                elementEmoji: elementalWeapon.elementEmoji,
                isElementalWeapon: true
            }));
        } else if (Math.random() < 0.7) {
            const elementalEffect = elementalCards[Math.floor(Math.random() * elementalCards.length)];
            playerDeck.push(new Card('elemental', emojis[elementalEffect.element], elementalEffect));
        } else {
            const utilityEffect = utilityCards[Math.floor(Math.random() * utilityCards.length)];
            playerDeck.push(new Card('utility', emojis[utilityEffect.type], utilityEffect));
        }
    }

    currentPlayerDeck = playerDeck.slice(); // Update currentPlayerDeck
    console.log('Player Deck created:', playerDeck);

    console.log('Player Deck created:', playerDeck);
    console.log('Player Deck created:', playerDeck);
    console.log('Elemental Cards:', elementalCards);
    console.log('Utility Cards:', utilityCards);
    console.log('Elemental Weapons:', elementalWeapons);

}


        function dealInitialHands() {
            for (let i = 0; i < 4; i++) {
                dealCard(playerHand);
                dealCard(opponentHand);
            }
        }

        function dealCard(hand) {
            if (hand.length < 4 && playerDeck.length > 0) {
                const card = playerDeck.pop();
                card.x = canvas.width / 2;
                card.y = canvas.height + card.height;
                card.scale = 0.1;
                hand.push(card);

                const dealSound = new Howl({
                    src: ['https://assets.caisual.com/games/zqfqt5j5yt3lzb0v/card_deal_sound.webp'],
                    volume: 0.5
                });
                dealSound.play();

                card.moveTo(
                    canvas.width / 2 - 1.5 * card.width + hand.length * (card.width + 10),
                    hand === playerHand ? canvas.height - card.height - 10 : 10,
                    () => {
                        card.scale = 1;
                        positionElements();
                    }
                );
            }
        }

        function createAvatars() {
            const avatarTypes = [
                { race: 'elf', emoji: emojis.elf },
                { race: 'dwarf', emoji: emojis.dwarf },
                { race: 'wizard', emoji: emojis.wizard },
                { race: 'fairy', emoji: emojis.fairy },
                { race: 'vampire', emoji: emojis.vampire },
                { race: 'merperson', emoji: emojis.merperson },
                { race: 'genie', emoji: emojis.genie },
                { race: 'zombie', emoji: emojis.zombie },
                { race: 'superhero', emoji: emojis.superhero },
                { race: 'supervillain', emoji: emojis.supervillain }
            ];

            for (let i = 0; i < 3; i++) {
                const playerAvatarType = avatarTypes[Math.floor(Math.random() * avatarTypes.length)];
                playerAvatars.push(new Avatar(playerAvatarType.race, playerAvatarType.emoji, true));

                const opponentAvatarType = avatarTypes[Math.floor(Math.random() * avatarTypes.length)];
                opponentAvatars.push(new Avatar(opponentAvatarType.race, opponentAvatarType.emoji, false));
            }
        }

        function positionElements() {
            const padding = 10;
            const avatarSpacing = canvas.width / 4;

            playerHand.forEach((card, index) => {
                card.x = canvas.width / 2 - 1.5 * card.width + index * (card.width + 10);
                card.y = canvas.height - card.height - 10;
            });

            playerAvatars.forEach((avatar, index) => {
                avatar.x = avatarSpacing * (index + 1) - avatar.width / 2;
                avatar.y = canvas.height - 2 * avatar.height - padding;
            });

            opponentAvatars.forEach((avatar, index) => {
                avatar.x = avatarSpacing * (index + 1) - avatar.width / 2;
                avatar.y = padding + avatar.height;
            });

            // Position deck placeholder
            if (playerHand.length > 0) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(10, canvas.height - playerHand[0].height - 10, 80, 120);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, canvas.height - playerHand[0].height - 10, 80, 120);
                ctx.fillStyle = '#000000';
                ctx.font = '20px Arial';
                ctx.fillText('Deck', 25, canvas.height - playerHand[0].height + 50);
                ctx.fillText(`(${playerDeck.length}/40)`, 15, canvas.height - playerHand[0].height + 80);
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw deck placeholder
            if (playerHand.length > 0) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(10, canvas.height - playerHand[0].height - 10, 80, 120);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, canvas.height - playerHand[0].height - 10, 80, 120);
                ctx.fillStyle = '#000000';
                ctx.font = '20px Arial';
                ctx.fillText('Deck', 25, canvas.height - playerHand[0].height + 50);
                ctx.fillText(`(${playerDeck.length}/40)`, 15, canvas.height - playerHand[0].height + 80);
            }

            playerHand.forEach(card => card.draw());
            playerAvatars.forEach(avatar => avatar.draw());
            opponentAvatars.forEach(avatar => avatar.draw());

            if (selectedCard) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(selectedCard.x, selectedCard.y, selectedCard.width, selectedCard.height);
            }

            // Draw turn and phase indicator
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.fillText(`Current Turn: ${currentTurn}`, 20, 30);
            ctx.fillText(`Phase: ${currentPhase}`, 20, 60);
        }

        function gameLoop() {
    if (!isCardBrowserVisible) {
        drawGame();
    }
    requestAnimationFrame(gameLoop);
}

        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('contextmenu', handleRightClick);

        function handleClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (currentTurn === 'player') {
                playerHand.forEach(card => {
                    if (card.isPointInside(x, y)) {
                        if (selectedCard === card) {
                            selectedCard.selected = false;
                            selectedCard = null;
                        } else {
                            if (selectedCard) selectedCard.selected = false;
                            card.selected = true;
                            selectedCard = card;
                        }
                    }
                });

                playerAvatars.forEach(avatar => {
                    if (avatar.isPointInside(x, y) && !avatar.isDead) {
                        if (selectedCard && currentPhase === 1) {
                            if (avatar.attachCard(selectedCard)) {
                                const index = playerHand.indexOf(selectedCard);
                                if (index > -1) {
                                    playerHand.splice(index, 1);
                                }
                                selectedCard = null;
                                if (avatar.attachedCards.length === avatar.maxAttachedCards) {
                                    currentPhase = 2;
                                }
                                positionElements();
                            } else {
                                avatar.shake();
                            }
                        } else if (currentPhase === 1 && !selectedCard) {
                            showAssignmentConfirmation();
                        } else if (currentPhase === 2 && !attackingAvatar) {
                            avatar.rotation = 15;
                            attackingAvatar = avatar;
                            showAttackConfirmation();
                        }
                    }
                });
            }
        }

        function handleRightClick(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            playerAvatars.concat(opponentAvatars).forEach(avatar => {
                if (avatar.isPointInside(x, y)) {
                    showAStatsBox(avatar);
                }
            });

            playerHand.forEach(card => {
                if (card.isPointInside(x, y)) {
                    showCardInfoBox(card);
                }
            });

            // Check if the deck was right-clicked
            if (x >= 10 && x <= 90 && y >= canvas.height - 130 && y <= canvas.height - 10) {
                showDeckOptions();
            }
        }

        function showAttackConfirmation() {
            attackConfirmation.style.display = 'block';
        }

        function confirmAttack(confirmed) {
            attackConfirmation.style.display = 'none';
            if (confirmed && attackingAvatar) {
                const target = getRandomAvatar(opponentAvatars.filter(avatar => !avatar.isDead));
                if (target) {
                    performAttack(attackingAvatar, target);
                } else {
                    endTurn();
                }
            } else {
                if (attackingAvatar) {
                    attackingAvatar.rotation = 0;
                }
                attackingAvatar = null;
            }
        }

        function showAssignmentConfirmation() {
            assignmentConfirmation.style.display = 'block';
        }

        function skipAssignmentPhase(skip) {
            assignmentConfirmation.style.display = 'none';
            if (skip) {
                currentPhase = 2;
            }
        }

        function performAttack(attacker, defender) {
            const hitChance = Math.floor(Math.random() * 10) + 1;
            if (attacker.luck + attacker.luckBonus >= hitChance) {
                const rawDamage = attacker.attack;
                const blockedDamage = Math.floor(defender.defense * 0.5);
                const damage = Math.max(0, rawDamage - blockedDamage);
                const attackAnimation = attacker.getAttackAnimation(defender);
                
                const attackSound = new Howl({
                    src: [`https://assets.caisual.com/games/zqfqt5j5yt3lzb0v/${attackAnimation.sound}`],
                    volume: 0.5
                });
                attackSound.play();

                attackAnimation.animate(() => {
                    defender.hp = Math.max(0, defender.hp - damage);
                    defender.showDamageAnimation(damage);

                    if (defender.hp === 0) {
                        defender.isDead = true;
                        flipCard(defender);
                    }

                    checkGameEnd();
                    if (gameStarted) {
                        endTurn();
                    }
                });
            } else {
                const missSound = new Howl({
                    src: ['https://assets.caisual.com/games/zqfqt5j5yt3lzb0v/attack_miss_sound.webp'],
                    volume: 0.5
                });
                missSound.play();

                ctx.font = '40px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.fillText('MISS!', defender.x + defender.width / 2, defender.y - 20);

                setTimeout(() => {
                    endTurn();
                }, 1000);
            }

            if (attackingAvatar) {
                attackingAvatar.rotation = 0;
            }
            attackingAvatar = null;
        }

        function flipCard(avatar) {
            avatar.rotation = 0;
            const flipAnimation = (progress) => {avatar.scale = Math.abs(Math.cos(progress * Math.PI));
                if (progress >= 1) {
                    avatar.isDead = true;
                } else {
                    requestAnimationFrame(() => flipAnimation(progress + 0.1));
                }
            };
            flipAnimation(0);
        }

        function getRandomAvatar(avatars) {
            return avatars[Math.floor(Math.random() * avatars.length)];
        }

        function endTurn() {
            currentTurn = currentTurn === 'player' ? 'opponent' : 'player';
            currentPhase = 1;
            updateSurrenderButtonVisibility();

            playerAvatars.concat(opponentAvatars).forEach(avatar => {
                avatar.updateLuckBonus();
            });

            // Remove any remaining hand cards and shuffle them back into the deck
            if (currentTurn === 'player') {
                while (playerHand.length > 0) {
                    playerDeck.push(playerHand.pop());
                }
                shuffleDeck(playerDeck);
                dealInitialHands();
            } else {
                while (opponentHand.length > 0) {
                    playerDeck.push(opponentHand.pop());
                }
                shuffleDeck(playerDeck);
                dealInitialHands();
                setTimeout(opponentTurn, 1000);
            }

            // Reshuffle if deck is low
            if (playerDeck.length <= 3) {
                const usedCards = playerAvatars.concat(opponentAvatars).flatMap(avatar => avatar.attachedCards);
                playerDeck = playerDeck.concat(usedCards);
                playerAvatars.concat(opponentAvatars).forEach(avatar => avatar.attachedCards = []);
                shuffleDeck(playerDeck);
            }
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i> 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function opponentTurn() {
            // Phase 1: Assign cards
            for (let i = 0; i < 2; i++) {
                if (opponentHand.length > 0) {
                    const card = opponentHand.pop();
                    const avatar = getRandomAvatar(opponentAvatars.filter(a => !a.isDead && a.attachedCards.length < a.maxAttachedCards));
                    if (avatar) {
                        avatar.attachCard(card);
                    } else {
                        playerDeck.push(card);
                    }
                }
            }

            // Phase 2: Attack
            const attacker = getRandomAvatar(opponentAvatars.filter(a => !a.isDead));
            const defender = getRandomAvatar(playerAvatars.filter(a => !a.isDead));
            if (attacker && defender) {
                performAttack(attacker, defender);
            } else {
                endTurn();
            }
        }

        function checkGameEnd() {
            if (playerAvatars.every(avatar => avatar.isDead)) {
                endGame("You lost!");
            } else if (opponentAvatars.every(avatar => avatar.isDead)) {
                endGame("You won!");
            }
        }

        function endGame(message) {
            gameStarted = false;
            gameOverMessage.textContent = message;
            gameOverMenu.style.display = 'block';
            bgm.stop();

            if (message === "You won!") {
                showConfetti();
            } else if (message === "You lost!") {
                showSkull();
            }
        }

        function showConfetti() {
            for (let i = 0; i < 100; i++) {
                createConfettiPiece();
            }
        }

        function createConfettiPiece() {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.top = `${Math.random() * 100}vh`;
            confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
            confetti.style.setProperty('--tx', `${(Math.random() - 0.5) * 300}px`);
            confetti.style.setProperty('--ty', `${Math.random() * 300 + 300}px`);
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 2000);
        }

        function showSkull() {
            const skull = document.createElement('div');
            skull.textContent = 'üíÄ';
            skull.style.position = 'absolute';
            skull.style.left = '50%';
            skull.style.top = '50%';
            skull.style.transform = 'translate(-50%, -50%)';
            skull.style.fontSize = '100px';
            document.body.appendChild(skull);
            setTimeout(() => skull.remove(), 2000);
        }

        function startNewGame() {
            gameOverMenu.style.display = 'none';
            playerDeck = [];
            playerHand = [];
            opponentHand = [];
            playerAvatars = [];
            opponentAvatars = [];
            selectedCard = null;
            currentTurn = 'player';
            attackingAvatar = null;
            startGame();
        }

        function showAStatsBox(avatar) {
            const cardColumn = aStatsBox.querySelector('.card-column');
            const statsColumn = aStatsBox.querySelector('.stats-column');

            cardColumn.innerHTML = '';
            statsColumn.innerHTML = '';

            const avatarCard = document.createElement('div');
            avatarCard.style.width = '100px';
            avatarCard.style.height = '150px';
            avatarCard.style.backgroundColor = 'white';
            avatarCard.style.display = 'flex';
            avatarCard.style.justifyContent = 'center';
            avatarCard.style.alignItems = 'center';
            avatarCard.style.fontSize = '50px';
            avatarCard.textContent = avatar.emoji;

            cardColumn.appendChild(avatarCard);

            const stats = [
                `Avatar: ${avatar.race}`,
                `HP: ${avatar.hp}/${avatar.maxHp}`,
                `Attack: ${avatar.attack}`,
                `Defense: ${avatar.defense}`,
                `Mana: ${avatar.mana}`,
                `Luck: ${avatar.luck + avatar.luckBonus}`
            ];

            stats.forEach(stat => {
                const statElement = document.createElement('p');
                statElement.textContent = stat.charAt(0).toUpperCase() + stat.slice(1);
                statsColumn.appendChild(statElement);
            });

            avatar.attachedCards.forEach((card, index) => {
                const attachedCardElement = document.createElement('button');
                attachedCardElement.className = 'effect-button';
                attachedCardElement.textContent = `${card.emoji} (${card.type})`;
                attachedCardElement.onclick = () => removeEffect(avatar, index);
                statsColumn.appendChild(attachedCardElement);
            });

            aStatsBox.style.display = 'grid';
        }

        function removeEffect(avatar, effectIndex) {
            const removedCard = avatar.removeEffect(effectIndex);
            if (removedCard) {
                playerDeck.push(removedCard);
                shuffleDeck(playerDeck);
                showAStatsBox(avatar);
            }
        }

        function showCardInfoBox(card) {
            const cardColumn = cardInfoBox.querySelector('.card-column');
            const statsColumn = cardInfoBox.querySelector('.stats-column');

            cardColumn.innerHTML = '';
            statsColumn.innerHTML = '';

            const cardDisplay = document.createElement('div');
            cardDisplay.style.width = '80px';
            cardDisplay.style.height = '120px';
            cardDisplay.style.backgroundColor = 'white';
            cardDisplay.style.display = 'flex';
            cardDisplay.style.justifyContent = 'center';
            cardDisplay.style.alignItems = 'center';
            cardDisplay.style.fontSize = '40px';
            cardDisplay.textContent = card.emoji;

            if (card.isLuckyStar) {
                cardDisplay.classList.add('lucky-star');
            }

            if (card.isElementalWeapon) {
                cardDisplay.classList.add('elemental-weapon');
                const elementalEmoji = document.createElement('span');
                elementalEmoji.style.position = 'absolute';
                elementalEmoji.style.bottom = '5px';
                elementalEmoji.style.right = '5px';
                elementalEmoji.style.fontSize = '20px';
                elementalEmoji.textContent = card.effect.elementEmoji;
                cardDisplay.appendChild(elementalEmoji);
            }

            cardColumn.appendChild(cardDisplay);

            const cardInfo = [
                `Type: ${card.type}`,
                `Effect: ${card.type === 'elemental' ? card.effect.element : card.effect.type}`
            ];

            if (card.isElementalWeapon) {
                cardInfo.push(`Element: ${card.effect.element}`);
            }

            cardInfo.forEach(info => {
                const infoElement = document.createElement('p');
                infoElement.textContent = info.charAt(0).toUpperCase() + info.slice(1);
                statsColumn.appendChild(infoElement);
            });

            cardInfoBox.style.display = 'grid';
        }

        function startTutorial() {
            tutorialOverlay.style.display = 'block';
            tutorialStep = 0;
            nextTutorialStep();
        }

        function nextTutorialStep() {
            const tutorialSteps = [
                "Welcome to Emoji RPG Battle! Let's go through the basics.",
                "Your avatar cards are at the bottom. They represent your characters in battle.",
                "Your hand of cards is below your avatars. These are elemental and utility cards.",
                "Click on a card in your hand to select it, then click on an avatar to attach it.",
                "You can attach up to 2 cards per avatar (3 with the Third Hand card).",
                "After assigning cards, click on an avatar to attack. Attacks are based on luck.",
                "Combine elemental and utility cards for powerful combo attacks!",
                "Right-click or long-press avatars and cards for more information.",
                "The game ends when all avatars on one side are defeated.",
                "That's it! Good luck and have fun!"
            ];

            if (tutorialStep < tutorialSteps.length) {
                tutorialContent.textContent = tutorialSteps[tutorialStep];
                tutorialStep++;
            } else {
                tutorialOverlay.style.display = 'none';
                setCookie('tutorialCompleted', 'true', 365);
            }
        }

        canvas.addEventListener('mousedown', handleLongPress);
        canvas.addEventListener('mouseup', cancelLongPress);
        canvas.addEventListener('mouseleave', cancelLongPress);

        let longPressTimer;

        function handleLongPress(event) {
            longPressTimer = setTimeout(() => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                playerAvatars.concat(opponentAvatars).forEach(avatar => {
                    if (avatar.isPointInside(x, y)) {
                        showAStatsBox(avatar);
                    }
                });

                playerHand.forEach(card => {
                    if (card.isPointInside(x, y)) {
                        showCardInfoBox(card);
                    }
                });

                // Check if the deck was long-pressed
                if (x >= 10 && x <= 90 && y >= canvas.height - 130 && y <= canvas.height - 10) {
                    showDeckOptions();
                }
            }, 500);
        }

        function cancelLongPress() {
            clearTimeout(longPressTimer);
        }

        document.addEventListener('click', (event) => {
            if (!aStatsBox.contains(event.target) && !cardInfoBox.contains(event.target) && !deckOptions.contains(event.target) && !cardBrowser.contains(event.target)) {
                aStatsBox.style.display = 'none';
                cardInfoBox.style.display = 'none';
                deckOptions.style.display = 'none';
                cardBrowser.style.display = 'none';
            }
        });



        function updateSurrenderButtonVisibility() {
            surrenderButton.style.display = currentTurn === 'player' ? 'block' : 'none';
        }

        function showDeckOptions() {
            deckOptions.style.display = 'block';
        }

        function saveDeck() {
            const gameState = {
                playerDeck: playerDeck,
                playerAvatars: playerAvatars
            };
            const jsonString = JSON.stringify(gameState);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${playerAvatars.map(avatar => avatar.race).join('_')}.deck`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadDeck(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const gameState = JSON.parse(e.target.result);
                    if (gameState.playerDeck && gameState.playerAvatars) {
                        playerDeck = gameState.playerDeck;
                        playerAvatars = gameState.playerAvatars;
                        initializeGame();
                    } else {
                        throw new Error("Invalid deck file");
                    }
                } catch (error) {
                    alert("Not a valid deck file");
                }
            };
            reader.readAsText(file);
        }

        function setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function initializeCardBrowser() {
    if (!cardBrowser) {
        console.error('cardBrowser element not found in the DOM');
        return;
    }

    // Set initial styles
    cardBrowser.style.display = 'none';
    cardBrowser.style.position = 'fixed';
    cardBrowser.style.top = '10%';
    cardBrowser.style.left = '10%';
    cardBrowser.style.width = '80%';
    cardBrowser.style.height = '80%';
    cardBrowser.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
    cardBrowser.style.color = 'white';
    cardBrowser.style.zIndex = '9999';
    cardBrowser.style.overflow = 'auto';
    cardBrowser.style.padding = '20px';
    cardBrowser.style.boxSizing = 'border-box';
    cardBrowser.style.border = '2px solid white';

    if (!cardGrid) {
        const newCardGrid = document.createElement('div');
        newCardGrid.id = 'cardGrid';
        cardBrowser.appendChild(newCardGrid);
    }

    if (!cardDetails) {
        const newCardDetails = document.createElement('div');
        newCardDetails.id = 'cardDetails';
        cardBrowser.appendChild(newCardDetails);
    }

    if (cardGrid) {
        cardGrid.style.display = 'grid';
        cardGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(100px, 1fr))';
        cardGrid.style.gap = '10px';
        cardGrid.style.padding = '10px';
    }
}

function checkOverlappingElements() {
    if (!cardBrowser) return;

    const cardBrowserRect = cardBrowser.getBoundingClientRect();
    const elements = document.elementsFromPoint(
        cardBrowserRect.left + cardBrowserRect.width / 2,
        cardBrowserRect.top + cardBrowserRect.height / 2
    );

    console.log("Elements at cardBrowser center:", elements.map(el => el.id || el.tagName));

    const overlappingElement = elements.find(el => el !== cardBrowser && el !== document.documentElement && el !== document.body);
    if (overlappingElement) {
        console.log("Potentially overlapping element:", overlappingElement.id || overlappingElement.tagName);
        console.log("Overlapping element styles:", window.getComputedStyle(overlappingElement));
    }
}

function toggleCardBrowserDebug() {
    isCardBrowserDebugMode = !isCardBrowserDebugMode;
    console.log("Card Browser Debug Mode:", isCardBrowserDebugMode ? "ON" : "OFF");
    showCardBrowser();
}


function showCardBrowser() {
    console.log("Showing card browser");
    if (!cardBrowser) {
        cardBrowser = document.createElement('div');
        cardBrowser.id = 'cardBrowser';
        document.body.appendChild(cardBrowser);
    }

    cardBrowser.style.display = 'flex';
    cardBrowser.style.flexDirection = 'column';
    cardBrowser.style.position = 'fixed';
    cardBrowser.style.top = '0';
    cardBrowser.style.left = '0';
    cardBrowser.style.width = '100%';
    cardBrowser.style.height = '100%';
    cardBrowser.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
    cardBrowser.style.color = 'white';
    cardBrowser.style.padding = '20px';
    cardBrowser.style.boxSizing = 'border-box';
    cardBrowser.style.zIndex = '2147483647';

    cardBrowser.innerHTML = `
        <div style="display: flex; height: calc(100% - 40px); gap: 20px;">
            <div style="width: 70%; display: flex; flex-direction: column;">
                <h2 id="cardBrowserHeader" style="margin-top: 0;">Template Cards</h2>
                <div id="cardGrid" style="width: 100%; flex-grow: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; padding-right: 10px;"></div>
            </div>
            <div style="width: 30%; display: flex; flex-direction: column;">
                <h2 style="margin-top: 0;">Card Details</h2>
                <div id="cardDetails" style="width: 100%;flex-grow: 1; background-color: rgba(255,255,255,0.1); padding: 10px; margin-bottom: 10px; overflow-y: auto; min-height: 300px;"></div>
                <button id="saveCardButton" style="padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer;">Add Card to Deck</button>
                <button id="showDeckButton" style="padding: 10px; margin-top: 10px; background-color: #008CBA; color: white; border: none; cursor: pointer;">Show Current Deck</button>
            </div>
        </div>
    `;

    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.position = 'absolute';
    closeBtn.style.top = '10px';
    closeBtn.style.right = '10px';
    closeBtn.style.padding = '5px 10px';
    closeBtn.style.backgroundColor = '#ff4444';
    closeBtn.style.color = 'white';
    closeBtn.style.border = 'none';
    closeBtn.style.borderRadius = '5px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.onclick = () => {
        cardBrowser.style.display = 'none';
        if (canvas) canvas.style.display = 'block';
    };
    cardBrowser.appendChild(closeBtn);

    // Initialize allTemplateCards if it's empty
    if (allTemplateCards.length === 0) {
        allTemplateCards = [
            ...elementalCards,
            ...utilityCards,
            ...elementalWeapons,
            ...specialCards
        ];
    }

    // Initialize the card browser with template cards
    populateCardGrid(allTemplateCards);
    setupCardBrowserEvents();
    updateCardBrowserHeader();

    if (canvas) canvas.style.display = 'none';
    console.log("Card browser setup complete");
}

function updateCardBrowserHeader() {
    const header = document.getElementById('cardBrowserHeader');
    if (header) {
        header.textContent = isViewingPlayerDeck ? "Your Current Deck" : "Template Cards";
    }
}


function showCardDetails(card) {
    console.log("Showing details for card:", card);
    const cardDetails = document.getElementById('cardDetails');
    if (!cardDetails) {
        console.error("Card details element not found");
        return;
    }
    if (!card) {
        console.error("Invalid card data:", card);
        cardDetails.innerHTML = '<p>Error: Card data is invalid</p>';
        return;
    }

    let cardName, cardType, cardEmoji, cardColor;
    let additionalDetails = '';

    if (card.element) {
        cardName = card.element;
        cardType = 'Elemental';
        cardEmoji = emojis[card.element.toLowerCase()] || emojis.unknown;
        cardColor = card.color || 'white';
        additionalDetails += `<p><strong>Element:</strong> ${card.element}</p>`;
    } else if (card.type) {
        if (card.type.includes('_')) {
            // Elemental weapon
            const [element, weapon] = card.type.split('_');
            cardName = `${element.charAt(0).toUpperCase() + element.slice(1)} ${weapon}`;
            cardType = 'Elemental Weapon';
            cardEmoji = card.elementEmoji || emojis[element.toLowerCase()] || emojis[weapon.toLowerCase()] || emojis.unknown;
            cardColor = elementalCards.find(ec => ec.element === element)?.color || 'white';
            additionalDetails += `<p><strong>Element:</strong> ${element}</p>`;
            additionalDetails += `<p><strong>Weapon:</strong> ${weapon}</p>`;
        } else if (specialCards?.some(sc => sc.type === card.type)) {
            // Special card
            cardName = card.type;
            cardType = 'Special';
            cardEmoji = emojis[card.type.toLowerCase()] || emojis.unknown;
            cardColor = 'gold';
            if (card.effect && card.effect.description) {
                additionalDetails += `<p><strong>Effect:</strong> ${card.effect.description}</p>`;
            }
        } else {
            // Utility card
            cardName = card.type;
            cardType = 'Utility';
            cardEmoji = emojis[card.type.toLowerCase()] || emojis.unknown;
            cardColor = 'white';
        }
    } else {
        console.error("Unrecognized card structure:", card);
        cardDetails.innerHTML = '<p>Error: Unrecognized card structure</p>';
        return;
    }

    // Capitalize the first letter of the card name
    cardName = cardName.charAt(0).toUpperCase() + cardName.slice(1);

    let detailsHTML = `
        <h3 style="margin-top: 0;">${cardName}</h3>
        <div style="font-size: 48px; text-align: center; margin: 10px 0;">${cardEmoji}</div>
        <p><strong>Type:</strong> ${cardType}</p>
        <p><strong>Rarity:</strong> ${card.rarity || 'N/A'}</p>
        ${additionalDetails}
    `;

    if (cardColor) {
        detailsHTML += `<p><strong>Color:</strong> <span style="background-color: ${cardColor}; padding: 2px 5px; border-radius: 3px; color: ${cardColor === 'white' ? 'black' : 'white'}">${cardColor}</span></p>`;
    }

    cardDetails.innerHTML = detailsHTML;
    console.log("Card details HTML updated");
}

// function populateCardGrid(cards) {
//     console.log("Populating card grid with", cards.length, "cards"); // Debugging line
//     const cardGrid = document.getElementById('cardGrid');
//     if (!cardGrid) {
//         console.error("Card grid element not found");
//         return;
//     }
//     cardGrid.innerHTML = '';
//     cards.forEach((card, index) => {
//         if (!card || !card.name) {
//             console.error("Invalid card data at index", index, ":", card);
//             return;
//         }
//         const cardElement = document.createElement('div');
//         cardElement.style.backgroundColor = card.color || 'white';
//         cardElement.style.color = card.color ? 'white' : 'black';
//         cardElement.style.padding = '10px';
//         cardElement.style.borderRadius = '5px';
//         cardElement.style.textAlign = 'center';
//         cardElement.style.cursor = 'pointer';
//         cardElement.style.display = 'flex';
//         cardElement.style.flexDirection = 'column';
//         cardElement.style.justifyContent = 'center';
//         cardElement.style.alignItems = 'center';
//         cardElement.style.height = '120px'; // Fixed height for consistency
//         cardElement.innerHTML = `
//             <div style="font-size: 24px; margin-bottom: 5px;">${card.emoji || '‚ùì'}</div>
//             <div style="font-weight: bold;">${card.name}</div>
//             <div style="font-size: 12px;">${card.type || 'Unknown'}</div>
//             ${isViewingPlayerDeck ? '<div style="font-size: 10px; margin-top: 5px;">Click to see details</div>' : ''}
//         `;
//         cardElement.onclick = (event) => {
//             console.log("Card clicked:", card.name); // Debugging line
//                       showCardDetails(card);
  
//             event.stopPropagation(); // Prevent event bubbling
//         };
//         cardGrid.appendChild(cardElement);
        
//         if (index === 0) {
//             console.log("First card element:", cardElement); // Debugging line
//         }
//     });
//     console.log("Card grid populated with", cardGrid.children.length, "card elements"); // Debugging line
// }

function populateCardGrid(cards) {
    console.log(`Populating card grid with ${cards.length} cards`);
    const cardGrid = document.getElementById('cardGrid');
    if (!cardGrid) {
        console.error("Card grid element not found");
        return;
    }
    cardGrid.innerHTML = '';

    cards.forEach((card, index) => {
        if (!card) {
            console.error("Invalid card data at index", index, ":", card);
            return;
        }

        const cardElement = document.createElement('div');
        
        // Determine card name, color, type, and emoji based on card structure
        let cardName, cardColor, cardType, cardEmoji;

        if (isViewingPlayerDeck) {
            // Player deck card structure
            cardName = card.effect?.element || card.effect?.type || card.type || 'Unknown';
            cardColor = card.effect?.color || 'white';
            cardType = card.type || 'Unknown';
            cardEmoji = card.emoji || emojis[cardName.toLowerCase()] || emojis.unknown;
        } else {
            // Template deck card structure
            if (card.element) {
                cardName = card.element;
                cardColor = card.color || 'white';
                cardType = 'Elemental';
                cardEmoji = emojis[card.element.toLowerCase()] || emojis.unknown;
            } else if (card.type) {
                if (card.type.includes('_')) {
                    // Elemental weapon
                    const [element, weapon] = card.type.split('_');
                    cardName = `${element.charAt(0).toUpperCase() + element.slice(1)} ${weapon}`;
                    cardColor = elementalCards.find(ec => ec.element === element)?.color || 'white';
                    cardType = 'Elemental Weapon';
                    cardEmoji = card.elementEmoji || emojis[element.toLowerCase()] || emojis[weapon.toLowerCase()] || emojis.unknown;
                } else if (specialCards?.some(sc => sc.type === card.type)) {
                    // Special card
                    cardName = card.type;
                    cardColor = 'gold';
                    cardType = 'Special';
                    cardEmoji = emojis[card.type.toLowerCase()] || emojis.unknown;
                } else {
                    // Utility card
                    cardName = card.type;
                    cardColor = 'white';
                    cardType = 'Utility';
                    cardEmoji = emojis[card.type.toLowerCase()] || emojis.unknown;
                }
            } else {
                console.error("Unrecognized card structure:", card);
                return; // Skip this card
            }
        }

        // Capitalize the first letter of the card name
        cardName = cardName.charAt(0).toUpperCase() + cardName.slice(1);

        // Log card details for debugging
        console.log(`Card: ${cardName}, Type: ${cardType}, Emoji: ${cardEmoji}`);

        cardElement.style.backgroundColor = cardColor;
        cardElement.style.color = cardColor !== 'white' ? 'white' : 'black';
        cardElement.style.padding = '10px';
        cardElement.style.borderRadius = '5px';
        cardElement.style.textAlign = 'center';
        cardElement.style.cursor = 'pointer';
        cardElement.style.display = 'flex';
        cardElement.style.flexDirection = 'column';
        cardElement.style.justifyContent = 'center';
        cardElement.style.alignItems = 'center';
        cardElement.style.height = '120px';
        cardElement.style.position = 'relative';  // For positioning the rarity indicator

        // Only add rarity class if it's defined and not empty
        if (card.rarity && typeof card.rarity === 'string' && card.rarity.trim() !== '') {
            cardElement.classList.add(`rarity-${card.rarity.trim()}`);
        }
        
        if (cardType === 'Special') cardElement.classList.add('special-card');

        cardElement.innerHTML = `
            ${card.rarity ? `<div class="rarity-indicator rarity-${card.rarity}"></div>` : ''}
            <div style="font-size: 24px; margin-bottom: 5px;">${cardEmoji}</div>
            <div style="font-weight: bold;">${cardName}</div>
            <div style="font-size: 12px;">${cardType}</div>
            ${cardType === 'Special' ? '<div style="font-size: 10px; color: gold;">Special</div>' : ''}
            ${isViewingPlayerDeck ? '<div style="font-size: 10px; margin-top: 5px;">Click to see details</div>' : ''}
        `;

        cardElement.onclick = (event) => {
            console.log("Card clicked:", cardName);
            event.stopPropagation();
            showCardDetails(card);
        };

        cardGrid.appendChild(cardElement);
        
        if (index === 0) {
            console.log("First card element:", cardElement);
        }
    });
    console.log(`Card grid populated with ${cardGrid.children.length} card elements`);
}

function setupCardBrowserEvents() {
    const saveCardButton = document.getElementById('saveCardButton');
    const showDeckButton = document.getElementById('showDeckButton');

    saveCardButton.onclick = () => {
        const cardDetails = document.getElementById('cardDetails');
        if (cardDetails.innerHTML !== '') {
            const cardName = cardDetails.querySelector('h3').textContent;
            if (isViewingPlayerDeck) {
                const cardIndex = currentPlayerDeck.findIndex(c => c && (c.name === cardName || c.type === cardName || c.element === cardName));
                if (cardIndex !== -1) {
                    currentPlayerDeck.splice(cardIndex, 1);
                    playerDeck = currentPlayerDeck.slice(); // Update the actual player deck
                    alert(`${cardName} removed from your deck!`);
                    populateCardGrid(currentPlayerDeck);
                    cardDetails.innerHTML = '';
                }
            } else {
                const card = allTemplateCards.find(c => c && (c.name === cardName || c.type === cardName || c.element === cardName));
                if (card && !currentPlayerDeck.some(c => c && (c.name === cardName || c.type === cardName || c.element === cardName))) {
                    currentPlayerDeck.push(JSON.parse(JSON.stringify(card))); // Deep copy the card
                    playerDeck = currentPlayerDeck.slice(); // Update the actual player deck
                    alert(`${cardName} added to your deck!`);
                    showCardDetails(card);
                } else {
                    alert("This card is already in your deck!");
                }
            }
        }
    };

    showDeckButton.onclick = () => {
        isViewingPlayerDeck = !isViewingPlayerDeck;
        if (isViewingPlayerDeck) {
            console.log("Switching to player deck view");
            currentPlayerDeck = playerDeck.slice(); // Create a copy of the player's deck
            populateCardGrid(currentPlayerDeck);
            showDeckButton.textContent = 'Show Template Cards';
            saveCardButton.textContent = 'Remove Card from Deck';
        } else {
            console.log("Switching to template cards view");
            populateCardGrid(allTemplateCards);
            showDeckButton.textContent = 'Show Current Deck';
            saveCardButton.textContent = 'Add Card to Deck';
        }
        updateCardBrowserHeader(); // Add this line to update the header
        document.getElementById('cardDetails').innerHTML = '';
    };
}

    showDeckButton.onclick = () => {
        isViewingPlayerDeck = !isViewingPlayerDeck;
        if (isViewingPlayerDeck) {
            populateCardGrid(playerDeck);
            showDeckButton.textContent = 'Show All Cards';
            saveCardButton.textContent = 'Remove Card from Deck';
        } else {
            populateCardGrid(allCards);
            showDeckButton.textContent = 'Show Current Deck';
            saveCardButton.textContent = 'Save Card to Deck';
        }
        document.getElementById('cardDetails').innerHTML = '';
    };


function initializeCards() {
    allCards = [
        ...elementalCards.map(card => ({
            name: card.element,
            emoji: emojis[card.element],
            type: 'Elemental',
            element: card.element,
            color: card.color
        })),
        ...utilityCards.map(card => ({
            name: card.type,
            emoji: emojis[card.type],
            type: 'Utility'
        })),
        ...elementalWeapons.map(card => ({
            name: card.type,
            emoji: emojis[card.weaponType],
            type: 'Elemental Weapon',
            element: card.element,
            weaponType: card.weaponType,
            elementEmoji: card.elementEmoji
        })),
        {
            name: 'Lucky Star',
            emoji: emojis.luckyStar,
            type: 'Special Utility'
        },
        {
            name: 'Third Hand',
            emoji: emojis.thirdHand,
            type: 'Special Utility'
        }
    ];

        // This function should populate allCards array
    // Make sure this is called before showCardBrowser
    console.log("Initializing all cards");
    // Your existing code to populate allCards
    console.log(`Initialized ${allCards.length} cards`);
}

function checkOverlappingElements() {
    if (!cardBrowser) return;

    const cardBrowserRect = cardBrowser.getBoundingClientRect();
    const elements = document.elementsFromPoint(
        cardBrowserRect.left + cardBrowserRect.width / 2,
        cardBrowserRect.top + cardBrowserRect.height / 2
    );

    console.log("Elements at cardBrowser center:", elements.map(el => `${el.tagName}#${el.id || 'no-id'}.${el.className || 'no-class'}`));

    const overlappingElement = elements.find(el => el !== cardBrowser && el !== document.documentElement && el !== document.body);
    if (overlappingElement) {
        console.log("Potentially overlapping element:", 
            `${overlappingElement.tagName}#${overlappingElement.id || 'no-id'}.${overlappingElement.className || 'no-class'}`);
        const style = window.getComputedStyle(overlappingElement);
        console.log("Overlapping element styles:", {
            position: style.position,
            zIndex: style.zIndex,
            display: style.display,
            visibility: style.visibility,
            opacity: style.opacity,
            width: style.width,
            height: style.height,
            top: style.top,
            left: style.left
        });
        console.log("Overlapping element dimensions:", overlappingElement.getBoundingClientRect());
    }

    // Check if cardBrowser is actually on top
    const topElement = elements[0];
    if (topElement !== cardBrowser) {
        console.log("Card browser is not the top element. Top element is:", 
            `${topElement.tagName}#${topElement.id || 'no-id'}.${topElement.className || 'no-class'}`);
    }
}

function checkAllZIndexes() {
    const allElements = document.body.getElementsByTagName('*');
    const zIndexes = Array.from(allElements).map(el => ({
        element: `${el.tagName}#${el.id || 'no-id'}.${el.className || 'no-class'}`,
        zIndex: window.getComputedStyle(el).zIndex
    })).filter(item => item.zIndex !== 'auto');

    console.log("All elements with non-auto z-index:", zIndexes);
}
function createCardBrowserIfNotExists() {
    if (!document.getElementById('cardBrowser')) {
        console.log("Creating cardBrowser dynamically");
        const cardBrowser = document.createElement('div');
        cardBrowser.id = 'cardBrowser';
        document.body.appendChild(cardBrowser);

        const cardGrid = document.createElement('div');
        cardGrid.id = 'cardGrid';
        cardBrowser.appendChild(cardGrid);

        const cardDetails = document.createElement('div');
        cardDetails.id = 'cardDetails';
        cardBrowser.appendChild(cardDetails);

        return cardBrowser;
    }
    return document.getElementById('cardBrowser');
}

function addCloseBtnToCardBrowser() {
    if (!cardBrowser) {
        console.error('cardBrowser element not found');
        return;
    }
    let closeBtn = cardBrowser.querySelector('.close-btn');
    if (!closeBtn) {
        closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.className = 'close-btn';
        closeBtn.style.position = 'absolute';
        closeBtn.style.top = '10px';
        closeBtn.style.right = '10px';
        closeBtn.style.padding = '5px 10px';
        closeBtn.style.backgroundColor = '#ff4444';
        closeBtn.style.color = 'white';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '5px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.zIndex = '2147483648'; // One higher than the cardBrowser to ensure it's on top

        closeBtn.onclick = (event) => {
            event.stopPropagation();
            cardBrowser.style.display = 'none';
            isCardBrowserVisible = false;
            isCardBrowserDebugMode = false;
           
            // Make the canvas visible again
            if (canvas) {
                canvas.style.display = 'block';
            }
        };

        cardBrowser.appendChild(closeBtn);
    }
}

function populateCardBrowser() {
    console.log("populateCardBrowser function called");
    cardGrid.innerHTML = '';
    cardDetails.innerHTML = '';

    if (!elementalCards || !utilityCards || !elementalWeapons || !avatarTypes) {
        console.error("One or more card arrays are undefined");
        return;
    }

    const allCards = [
        ...elementalCards.map(card => ({ type: 'elemental', ...card })),
        ...utilityCards.map(card => ({ type: 'utility', ...card })),
        ...elementalWeapons.map(card => ({ type: 'elemental weapon', ...card })),
        { type: 'special utility', name: 'Lucky Star', emoji: emojis.luckyStar },
        { type: 'special utility', name: 'Third Hand', emoji: emojis.thirdHand },
        ...avatarTypes.map(avatar => ({ type: 'avatar', ...avatar }))
    ];

    console.log("Total cards to display:", allCards.length);

    allCards.forEach((card, index) => {
        const cardItem = document.createElement('div');
        cardItem.className = 'card-item';
        cardItem.style.backgroundColor = 'white';
        cardItem.style.color = 'black';
        cardItem.style.padding = '10px';
        cardItem.style.borderRadius = '5px';
        cardItem.style.textAlign = 'center';
        cardItem.style.cursor = 'pointer';
        
        const emoji = document.createElement('div');
        emoji.style.fontSize = '40px';
        emoji.textContent = card.emoji || card.elementEmoji || emojis[card.element] || emojis[card.type] || '?';
        
        const name = document.createElement('div');
        name.textContent = card.name || card.element || card.type;
        name.style.marginTop = '5px';
        
        cardItem.appendChild(emoji);
        cardItem.appendChild(name);
        
        cardItem.onclick = () => showCardDetails(card);
        cardGrid.appendChild(cardItem);
        
        if (index === 0) {
            console.log("First card added:", emoji.textContent);
        }
    });

    console.log("Cards added to grid:", cardGrid.children.length);
}

    </script>
</body>

</html>